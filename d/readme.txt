iolite.exe で test.li
を開くと　コンパイルされます。

言語的にはForthみたいな感じです。

まぁかなり違うところもあると思いますが...




ざっくりいうと逆ポーランドで書けば動きます。
今のところ対応している演算子は

+
-
*
/
%
~
|
&
^
!
||
&&
<<
>>
@
@@




==
!=
>=
<=
>
<

です。

浮動少数は今のところ扱えません
構造体、配列もないです。(メモリ操作により実現可能)



"jsl;kgj;sdfk"
文字列リテラルです。
スタックに文字列へのポインタがpushされます。


0xF784A
20985
'a'
整数リテラルです。
スタックに整数の値がpushされます。


uselib "user32.dll"
efunc MessageBoxA
DLLを選択し、外部関数を定義します


func(a b c d e)aiueo
引数a b c d e を持つ関数 aiueoを宣言します
それ以降に続く内容が処理となります


var i
ローカル変数iを宣言します


array 100 b
100*4バイト(整数100個分)の大きさを持つローカル変数bを宣言します。


svar i
静的(static)変数iを宣言します


sarray 100 b
100*4バイト(整数100個分)の大きさを持つ静的(static)変数bを宣言します。

fff::count
静的変数を別の関数からアクセスし、その内容をpush 
この場合　関数fffに属する静的変数countにアクセスする
ただし同じ名前のローカル変数が存在しないなら fff::が
なくてもアクセス可能

$fff::count
静的変数を別の関数からアクセスし、その変数のポインタをpush 
この場合　関数fffに属する静的変数countにアクセスする
ただし同じ名前のローカル変数が存在しないなら fff::が
なくてもアクセス可能

var aaa
$aaa
変数aaaのポインタをpushします。
静的変数でも同様にポインタを
関数・外部関数であれば関数のポインタをpushします。


;
スタックトップを一個破棄します。


$a 10 = ;
[変数のポインタ] [10] = で変数に対して10を代入します。
代入演算子の戻り値は　10　です。戻り値はいらないので
 ; で破棄します。

$a ++ ;
$b ++ ;
変数に対して 1 加算/減算します。

aaa @
変数aaaの中身の示すメモリの内容をPUSHします。

aaa @@
変数aaaの中身の示す内容が関数のポインタであったとき
その関数を呼び出します。
数値が関数のポインタでない場合、
たぶん暴走します。もしくはエラー。


:loop
ローカルなラベルloopを宣言します。
グローバルなラベルというの存在しません。
関数内でしかジャンプできません


goto:loop
ラベルloopにジャンプします


gotrue:loop
スタックトップが真ならスタックを破棄してジャンプします。
偽ならスタックを破棄せず次の処理に移行します。
真とは ゼロでないもののことを言います
偽とは　ゼロのことを言います


gofalse:loop
スタックトップが偽ならスタックを破棄してジャンプします。
真ならスタックを破棄せず次の処理に移行します。
真とは ゼロでないもののことを言います
偽とは　ゼロのことを言います


(0 "Title" "sentence" 0)MessageBoxA;
関数は必ず戻り地があるとし、EAXの内容をスタックにPUSHします。
その値を必要としない場合は " ; " で 破棄してください
stdcallしか今のところ呼び出せません。
cdeclもいつか実装します


0 "Title" "sentence" 0　MessageBoxA;
関数呼び出しの際 ( ) は必須ではありません。
関数の宣言には必須です。
見易さのために適当に付加してやってください。
1 2 + 
も
(1 2)+ としたり
(1 2 +)という風にできます。
lispっぽくもできるわけです。順番は違いますが。


return
スタックトップをひとつ消費して
その値を戻り値とします。


ちなみにmain関数から始まるということではなく
一番上にある関数から実行されます。